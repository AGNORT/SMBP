#include "labelSetting.h"
#define MAXMUMHEUCGTIME 180

using namespace std;

//the original instances information used to replace the sorted instances
Instance g_orgInstance = { 0 };

//control the solutio time of MIP
double g_MIPMaxTime = 10;				//the maximum time allowed to solve the MIP in seconds

//control the decimals to keep of the dual variables
double g_controlNum = 1000;
int g_maxItemNum = 0;					//maximum number of items can be contained in one bin
int g_binpackingUB = 1e10;				//the upper bound of the bin packing problem

//control use the lower or upper bound of dual variables
int g_upper_lower_dual = 0;				//0 indicates using upper bounds(don't truncating), 1 indicates using lower bounds(truncating dual variables), 2 indicates using original dual variables

//control the dual bound calculation using the fixed parameter or variable parameters
int g_dual_bound_parameter = 1;			//0 denote using fixed parameters and 1 denotes using variable parameters

//control the using of the compact model
bool g_useCompactModel = true;			//if use the compact model to solve the submodular bin packing problem, only use for instances with 100 items

//SR3 inequalities parameter
vector<vector<int>> g_allSR3Comb;		//all the candidates of SR3
int g_maxNumSR3Comb = 0;			//the maximum number of SR3s to add originally 10000, set to 0 to mask it

//DOI parameters
map<double, pair<int, unordered_set<int>>> g_DOIsCandidates;			//DOIs candidates
int g_maxNumDIs = 10000;					//the maximum number of DIs to add, set to 0 means we don't use DIs

//solution
vector<Bin*> g_bestSol_binpacking;		//best solution for the bin packing problem
int g_patternBranchNum = 0;				//the number of pattern branches
int g_arcBranchNum = 0;					//the number of arc branches
int g_SR3Num = 0;						//the number of SR3 added into the MP
double g_dualRootNode = 0;				//the dual bound after solving the root node
double g_worstDual = 0;					//the dual bound with highest value during the branching
double g_BPTime = 0;					//the total time for BP
double g_heuristicTime = 0;				//the time spent on heuristic to solve submodular Bin packing
double g_adjustStagesTime = 0;			//the time spent on adjusting stages
double g_pricingTime = 0;				//the time spent on the pricing subproblem
bool g_timeLimitReach = false;			//mark if the time limit is reached or not
int g_CGIterations = 0;					//the CG iterations
int g_validDOIs = 0;					//the DOIs added to the MP in the root node
int g_reRunMPwithoutDOIs = false;		//if the DOIs are selected in the basis of the MP or not
int g_maxNodeDepth = 0;					//the maximum depth of the branch and price tree
int g_nodeDepthSum = 0;					//the sum of the node depth in the branch and price tree
int g_HLACols = 0;						//the number of columns generated by the HLA
int g_ELACols = 0;						//the number of columns generated by the ELA

void SeparateSR3(
	unordered_map<int, double>& preSolution,
	vector<Bin*>& preCols,
	vector<unordered_set<int>>& preSR3s,
	vector<unordered_set<int>>& newSR3s
);

bool ColumnAndCutsGeneration(
	vector<unordered_set<int>>& newAddedSR3s,
	BranchNode* preNode,
	ofstream& outPut);

double ColumnGeneration(
	BranchNode* preNode,
	bool& integerFlag,
	bool rootFlag,
	ofstream& outPut,
	bool heuCG = false);

//read instances
void ReadInstances(Args& args) {
	g_instance = { 0 };
	if (instance_parse(&g_instance, args.input_file)) {
		cerr << "Error reading g_instance file" << endl;
		return;
	}
	std::ifstream infile(args.input_file);
	if (!infile.is_open()) {
		std::cerr << "Error: Cannot open file " << args.input_file << std::endl;
		exit(-1);
	}
	//read head line
	infile >> g_instance.n_items >> g_instance.capacity >> g_instance.rho;
	//read item information
	g_instance.a_ptr = new double[g_instance.n_items];
	g_instance.b_ptr = new double[g_instance.n_items];
	g_instance.p_ptr = new double[g_instance.n_items];
	g_instance.p_weight = new double[g_instance.n_items];
	for (size_t i = 0; i < g_instance.n_items; ++i) {
		string pStr, aStr, bStr;
		infile >> pStr >> aStr >> bStr;

		g_instance.a_ptr[i] = stod(aStr);
		g_instance.b_ptr[i] = stod(bStr);
		g_instance.p_ptr[i] = stod(pStr);
		g_instance.p_weight[i] = g_instance.p_ptr[i] / (g_instance.a_ptr[i] + sqrt(g_instance.b_ptr[i]));
	}
	infile.close();

	if (g_instance.rho < 1 && !args.direct_rho)
		g_instance.rho = sqrt(g_instance.rho) / sqrt(1 - g_instance.rho);
	ofstream outPut(args.output_file, ios::app);
	//judge if p and a is integer or not
	for (int i = 0; i < g_instance.n_items; ++i) {
		if (abs(floor(g_instance.a_ptr[i]) - g_instance.a_ptr[i]) > EX) {
			g_aInteger = false;
		}
		double preRatio = g_instance.b_ptr[i] * 1.0 / (g_instance.a_ptr[i] * 1.0);
		if (preRatio < g_smallest_bDiva)
			g_smallest_bDiva = preRatio;
		//the initial profit for eachitem should be zero
		//g_instance.p_ptr[j] = 0;
	}
	g_pInteger = false;
	g_tolItemNum = g_instance.n_items;			//the first dimension of the bucket
}

//copy instance
void CopyInstance(Instance& preInstance, Instance& orgInstance) {
	if (preInstance.a_ptr != nullptr) {
		free(preInstance.a_ptr);
		free(preInstance.b_ptr);
		free(preInstance.p_ptr);
		free(preInstance.p_weight);
	}
	double* new_a = (double*)malloc(orgInstance.n_items * sizeof(double));
	double* new_b = (double*)malloc(orgInstance.n_items * sizeof(double));
	double* new_p = (double*)malloc(orgInstance.n_items * sizeof(double));
	double* new_pw = (double*)malloc(orgInstance.n_items * sizeof(double));

	for (size_t i = 0; i < orgInstance.n_items; ++i) {
		new_a[i] = orgInstance.a_ptr[i];
		new_b[i] = orgInstance.b_ptr[i];
		new_p[i] = orgInstance.p_ptr[i];
		new_pw[i] = orgInstance.p_weight[i];
		double preRatio = new_b[i] * 1.0 / (new_a[i] * 1.0);
		if (g_smallest_bDiva < 1e10 && preRatio < g_smallest_bDiva)
			g_smallest_bDiva = preRatio;
	}
	preInstance.a_ptr = new_a;
	preInstance.b_ptr = new_b;
	preInstance.p_ptr = new_p;
	preInstance.p_weight = new_pw;
	preInstance.n_items = orgInstance.n_items;
}

//copy solution
void CopySolution(vector<Bin*>& bestSol, vector<Bin*>& orgSol) {
	if (!bestSol.empty()) {
		for (auto& e : bestSol) {
			delete e;
			e = nullptr;
		}
	}
	bestSol.resize(orgSol.size());
	for (int i = 0; i < orgSol.size(); ++i)
		bestSol[i] = new Bin(orgSol[i]);
}

//Generate initial columns
void GenerateInitCols(vector<Bin*>& rootCols) {
	//single item bins
	for (int i = 0; i < g_tolItemNum; ++i) {
		Bin* newBin = new Bin;
		newBin->itemSet.resize(g_tolItemNum, 0);
		newBin->itemSet[i] = 1;
		newBin->tolProfit = g_instance.p_ptr[i];
		newBin->tolWeight = g_instance.a_ptr[i] +
			g_instance.rho * sqrt(g_instance.b_ptr[i]);
		rootCols.push_back(newBin);
	}
}


//construct RMP
void CreateRMP(
	vector<GRBVar>& preVars,
	vector<Bin*>& preCols,
	vector<unordered_set<int>>& preSR3s,
	vector<GRBConstr>& preCons,
	GRBModel& master
) {
	//set objective function
	GRBLinExpr obj = 0;
	for (int i = 0; i < preCols.size(); ++i)
		obj += preVars[i];
	master.setObjective(obj, GRB_MINIMIZE);

	//add constraints - item degree constraints
	for (int j = 0; j < g_tolItemNum; ++j) {
		GRBLinExpr lhs = 0;
		for (int i = 0; i < preVars.size(); ++i)
			lhs += preCols[i]->itemSet[j] * preVars[i];
		preCons.push_back(master.addConstr(lhs >= 1));
	}
	//add SR3 constraints
	for (auto& SR3 : preSR3s) {
		GRBLinExpr lhs = 0;
		int node1 = *SR3.begin();
		int node2 = *(++SR3.begin());
		int node3 = *(++(++SR3.begin()));
		for (int i = 0; i < preVars.size(); ++i) {
			if (
				(preCols[i]->itemSet[node1] && preCols[i]->itemSet[node2]) ||
				(preCols[i]->itemSet[node1] && preCols[i]->itemSet[node3]) ||
				(preCols[i]->itemSet[node2] && preCols[i]->itemSet[node3])
				)
				lhs += preVars[i];
		}
		preCons.push_back(master.addConstr(lhs <= 1));
	}
	////add constraints - the bin number bound constraints
	//GRBLinExpr tSum = 0;
	//for (int j = 0; j < preVars.size(); ++j)
	//	tSum += preVars[j];
	//preCons.push_back(master.addRange(tSum, branchBins.first, branchBins.second));
}

//Judge the CG terminate or not, premature termination strategy
bool JgeTermination(double& presentRC, double& preObj, bool lowerDual) {
	double lowerBoundRC = presentRC;
	if (lowerDual)
		lowerBoundRC -= g_maxItemNum * 1.0 / g_controlNum;//obtain the lower bound of the reduced cost, when truncating the dual variables

	return
		abs(floor(preObj + g_binpackingUB * lowerBoundRC) -
			floor(preObj)) <= EX;
}

//Generate Dual Optimal Inequalities
void GenerateDOIs() {
	//separate DOIs with 3 items
	//for (auto& e : g_allSR3Comb) {
	//	if(g_instance.a_ptr[e[0]] + g_instance.a_ptr[e[1]] <= g_instance.a_ptr[e[2]] && 
	//		g_instance.b_ptr[e[0]] + g_instance.b_ptr[e[1]] <= g_instance.b_ptr[e[2]]) {
	//		double diff = g_instance.a_ptr[e[2]] - g_instance.a_ptr[e[0]] - g_instance.a_ptr[e[1]] 
	//			+ g_instance.b_ptr[e[2]] - g_instance.b_ptr[e[0]] - g_instance.b_ptr[e[1]];
	//		g_DOIsCandidates.insert({ diff, {e[0],e[1],e[2]} });
	//		if(g_DOIsCandidates.size() > g_maxNumDIs)
	//			g_DOIsCandidates.erase(--g_DOIsCandidates.end());//remove the smallest DOI
	//	}
	//	if (g_instance.a_ptr[e[0]] + g_instance.a_ptr[e[2]] <= g_instance.a_ptr[e[1]] &&
	//		g_instance.b_ptr[e[0]] + g_instance.b_ptr[e[2]] <= g_instance.b_ptr[e[1]]) {
	//		double diff = g_instance.a_ptr[e[1]] - g_instance.a_ptr[e[0]] - g_instance.a_ptr[e[2]]
	//			+ g_instance.b_ptr[e[1]] - g_instance.b_ptr[e[0]] - g_instance.b_ptr[e[2]];
	//		g_DOIsCandidates.insert({ diff, { e[0],e[2],e[1] } });
	//		if (g_DOIsCandidates.size() > g_maxNumDIs)
	//			g_DOIsCandidates.erase(--g_DOIsCandidates.end());//remove the smallest DOI
	//	}
	//	if (g_instance.a_ptr[e[1]] + g_instance.a_ptr[e[0]] <= g_instance.a_ptr[e[2]] &&
	//		g_instance.b_ptr[e[1]] + g_instance.b_ptr[e[0]] <= g_instance.b_ptr[e[2]]) {
	//		double diff = g_instance.a_ptr[e[2]] - g_instance.a_ptr[e[1]] - g_instance.a_ptr[e[0]]
	//			+ g_instance.b_ptr[e[2]] - g_instance.b_ptr[e[1]] - g_instance.b_ptr[e[0]];
	//		g_DOIsCandidates.insert({ diff,{ e[1],e[0],e[2] } });
	//		if (g_DOIsCandidates.size() > g_maxNumDIs)
	//			g_DOIsCandidates.erase(--g_DOIsCandidates.end());//remove the smallest DOI
	//	}
	//	if (g_instance.a_ptr[e[1]] + g_instance.a_ptr[e[2]] <= g_instance.a_ptr[e[0]] &&
	//		g_instance.b_ptr[e[1]] + g_instance.b_ptr[e[2]] <= g_instance.b_ptr[e[0]]) {
	//		double diff = g_instance.a_ptr[e[0]] - g_instance.a_ptr[e[1]] - g_instance.a_ptr[e[2]]
	//			+ g_instance.b_ptr[e[0]] - g_instance.b_ptr[e[1]] - g_instance.b_ptr[e[2]];
	//		g_DOIsCandidates.insert({ diff,{ e[1],e[2],e[0] } });
	//		if (g_DOIsCandidates.size() > g_maxNumDIs)
	//			g_DOIsCandidates.erase(--g_DOIsCandidates.end());//remove the smallest DOI
	//	}
	//	if (g_instance.a_ptr[e[2]] + g_instance.a_ptr[e[1]] <= g_instance.a_ptr[e[0]] &&
	//		g_instance.b_ptr[e[2]] + g_instance.b_ptr[e[1]] <= g_instance.b_ptr[e[0]]) {
	//		double diff = g_instance.a_ptr[e[0]] - g_instance.a_ptr[e[1]] - g_instance.a_ptr[e[2]]
	//			+ g_instance.b_ptr[e[0]] - g_instance.b_ptr[e[1]] - g_instance.b_ptr[e[2]];
	//		g_DOIsCandidates.insert({ diff,{ e[2],e[1],e[0] } });
	//		if (g_DOIsCandidates.size() > g_maxNumDIs)
	//			g_DOIsCandidates.erase(--g_DOIsCandidates.end());//remove the smallest DOI
	//	}
	//	if (g_instance.a_ptr[e[2]] + g_instance.a_ptr[e[0]] <= g_instance.a_ptr[e[1]] &&
	//		g_instance.b_ptr[e[2]] + g_instance.b_ptr[e[0]] <= g_instance.b_ptr[e[1]]) {
	//		double diff = g_instance.a_ptr[e[1]] - g_instance.a_ptr[e[0]] - g_instance.a_ptr[e[2]]
	//			+ g_instance.b_ptr[e[1]] - g_instance.b_ptr[e[0]] - g_instance.b_ptr[e[2]];
	//		g_DOIsCandidates.insert({ diff,{ e[2],e[0],e[1] } });
	//		if (g_DOIsCandidates.size() > g_maxNumDIs)
	//			g_DOIsCandidates.erase(--g_DOIsCandidates.end());//remove the smallest DOI
	//	}
	//}

	//separate DOIs with item set
	Instance tmpInstance = { 0 };
	CopyInstance(tmpInstance, g_instance);

	//descending the instances by a + pho*sqrt(b)
	ItemIndex* indicesRec = nullptr;
	sort_instance_by_weight(tmpInstance, indicesRec);

	//separate the item set for each item greedily
	for (int i = 0; i < tmpInstance.n_items; ++i) {
		unordered_set<int> preSet = { (int)indicesRec[i].index };
		double sum_a = 0, sum_b = 0;
		int j = 0;
		bool resetFlag = true;
		double lastAddKey = -1;
		while (j < tmpInstance.n_items) {
			if (i == j) {
				++j;
				continue;
			}
			sum_a += tmpInstance.a_ptr[j];
			sum_b += tmpInstance.b_ptr[j];
			if (sum_a <= tmpInstance.a_ptr[i] && sum_b <= tmpInstance.b_ptr[i]) {
				preSet.insert(indicesRec[j].index);
				double diff = tmpInstance.a_ptr[i] - sum_a + tmpInstance.b_ptr[i] - sum_b;
				g_DOIsCandidates.insert({ diff, {indicesRec[i].index, preSet} });

				if (resetFlag) {//对于某个j，后面添加的约束可以统治前面添加的约束
					resetFlag = false;
				}
				else {
					auto ite = g_DOIsCandidates.find(lastAddKey);
					if (ite != g_DOIsCandidates.end())
						g_DOIsCandidates.erase(ite);
				}
				lastAddKey = diff;

				if (g_DOIsCandidates.size() > g_maxNumDIs)
					g_DOIsCandidates.erase(--g_DOIsCandidates.end());//remove the smallest DOI
			}
			else {
				if ((preSet.size() == 1 || preSet.size() == 2) &&
					(sum_a > tmpInstance.a_ptr[i] || sum_b > tmpInstance.b_ptr[i]))
					break;//afterwards cannot find feasible sets
				sum_a = 0;
				sum_b = 0;
				preSet.clear();
				preSet = { (int)indicesRec[i].index };
				--j;
				resetFlag = true;
				continue;
			}
			++j;
		}
	}

	g_validDOIs = g_DOIsCandidates.size();
	//free instances
	instance_free(&tmpInstance);
	free(indicesRec);
}

//construct RMP for the root node
void CreateRMP_rootNode(
	vector<GRBVar>& preVars,
	vector<GRBVar>& preDualVars,
	vector<Bin*>& preCols,
	vector<unordered_set<int>>& preSR3s,
	vector<GRBConstr>& preCons,
	GRBModel& master
) {
	//set objective function
	GRBLinExpr obj = 0;
	for (int i = 0; i < preCols.size(); ++i)
		obj += preVars[i];
	master.setObjective(obj, GRB_MINIMIZE);

	//add constraints - item degree constraints
	for (int j = 0; j < g_tolItemNum; ++j) {
		GRBLinExpr lhs = 0;
		for (int i = 0; i < preVars.size(); ++i)
			lhs += preCols[i]->itemSet[j] * preVars[i];
		//consider DOIs
		auto ite = g_DOIsCandidates.begin();
		int cnt = 0;
		while (ite != g_DOIsCandidates.end()) {
			auto tIte = ite->second.second.find(j);
			if (tIte != ite->second.second.end()) {
				if (j != ite->second.first)
					lhs += preDualVars[cnt];
				else
					lhs -= preDualVars[cnt];
			}
			++cnt;
			++ite;
		}

		preCons.push_back(master.addConstr(lhs >= 1));
	}
	//add SR3 constraints
	for (auto& SR3 : preSR3s) {
		GRBLinExpr lhs = 0;
		int node1 = *SR3.begin();
		int node2 = *(++SR3.begin());
		int node3 = *(++(++SR3.begin()));
		for (int i = 0; i < preVars.size(); ++i) {
			if (
				(preCols[i]->itemSet[node1] && preCols[i]->itemSet[node2]) ||
				(preCols[i]->itemSet[node1] && preCols[i]->itemSet[node3]) ||
				(preCols[i]->itemSet[node2] && preCols[i]->itemSet[node3])
				)
				lhs += preVars[i];
		}
		preCons.push_back(master.addConstr(lhs <= 1));
	}
}

//Conduct the column generation
double ColumnGeneration_rootNode(
	BranchNode* preNode,
	bool& integerFlag,
	bool rootFlag,
	ofstream& outPut,
	bool heuCG = false) {
	int preCGiteration = 0;			//record the CG iteration
	int preCallHeuDP = 0;			//record the number of heuristic DP calls
	int preCallExactDP = 0;			//record the number of exact DP calls
	double heuDPTime = 0;			//time spent on the heuristic DP
	double exactDPTime = 0;			//time spent on the exact DP
	integerFlag = true;
	//cout << "Start generate DOIs! " << endl;
	GenerateDOIs();					//generate the DOIs candidates
	//cout << "Finish generate DOIs! " << endl;

	auto startTime = chrono::high_resolution_clock::now();
	double preLowerBound = g_tolItemNum;
	vector<Bin*> preBestSolution;
	try {
		/*setting the node*/
		GRBEnv preEnv = GRBEnv(true);
		//cout << "Turn off the log! " << endl;
		preEnv.set(GRB_IntParam_OutputFlag, 0); // turn off the log
		//cout << "Start the env! " << endl;
		preEnv.start();
		//cout << "Start the model! " << endl;
		GRBModel master = GRBModel(preEnv);
		//cout << "Set solution method! " << endl;
		master.set(GRB_IntParam_Method, 0); //0, primal; 1 dual, 2 barrier, 3 concurrent
		vector<GRBVar> colVars;
		vector<GRBVar> dualVars;
		//add columns into RMP
		//cout << "Start adding cols! " << endl;
		for (int i = 0; i < preNode->allCols.size(); ++i) {
			GRBVar var = master.addVar(0.0, 1.0, 1.0, GRB_CONTINUOUS);
			colVars.emplace_back(var);//record each column variable
		}
		//add DOI columns
		//cout << "Start adding DOIs! " << endl;
		for (auto& DOIs : g_DOIsCandidates) {
			GRBVar var = master.addVar(0.0, 1.0, 1.0, GRB_CONTINUOUS);
			dualVars.emplace_back(var);//record each column variable
		}
		//record all the added preCons
		vector<GRBConstr> allCons;
		//construct RMP
		//cout << "Start create root node! " << endl;
		CreateRMP_rootNode(colVars, dualVars, preNode->allCols, preNode->SR3s, allCons, master);

		/*The loop of CG*/
		while (true) {
			++g_CGIterations;
			//control the solution time
			auto endTime = chrono::high_resolution_clock::now();
			if (g_BPTime + chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0 >= MAXMUMSOLTIME) {
				g_timeLimitReach = true;
				break;
			}
			//control the heuristic CG time
			if (heuCG &&
				g_BPTime + chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0 >= MAXMUMHEUCGTIME) {
				break;
			}

			//cout << "Start solving the MP! " << endl;
			master.optimize();
			if (master.get(GRB_IntAttr_Status) != GRB_OPTIMAL) {
				cerr << "The master problem is not solved to optimal!" << endl;
				preLowerBound = g_tolItemNum;
				break;
			}
			cout << "The present lower bound is: " << master.get(GRB_DoubleAttr_ObjVal) << endl;

			//reset the instances
			CopyInstance(g_instance, g_orgInstance);

			//get dual variables
			vector<double> preciseDuals;
			vector<double> tmpDualsRec;
			vector<double> SR3Duals;		//dual variables related to SR3s
			for (int c = 0; c < allCons.size(); ++c) {
				tmpDualsRec.push_back(allCons[c].get(GRB_DoubleAttr_Pi));//the precise dual variables
				if (c < g_instance.n_items) {
					preciseDuals.push_back(allCons[c].get(GRB_DoubleAttr_Pi));//the precise dual variables
					if (g_upper_lower_dual == 1) {
						//use truncating dual variable
						g_instance.p_ptr[c] = int(floor(g_controlNum * allCons[c].get(GRB_DoubleAttr_Pi))) * 1.0 / g_controlNum;
					}
					else if (g_upper_lower_dual == 0) {
						//use upper bound of the dual variables
						g_instance.p_ptr[c] = int(ceil(g_controlNum * allCons[c].get(GRB_DoubleAttr_Pi))) * 1.0 / g_controlNum;
					}
					else {
						//use original dual variable
						g_instance.p_ptr[c] = allCons[c].get(GRB_DoubleAttr_Pi);
					}
				}
				else {
					SR3Duals.push_back(allCons[c].get(GRB_DoubleAttr_Pi));
				}
			}

			//Solve the subproblem to generate new columns
			vector<Bin*> newCols;
			double preTime = 0;
			bool hasNewColumn = false;
			double rcLB = 0;
			if (rootFlag)
				//hasNewColumn = SolveCompactPricingModel(newCols, outPut, preNode->stages, preTime, binNumDual, preciseDuals);
				hasNewColumn = LabelSettingSolveSubproblem(newCols, outPut, preNode->allCols, preTime, preciseDuals, rcLB, true);
			else
				//hasNewColumn = SolveCompactPricingModel(newCols, outPut, preNode->stages, preTime, binNumDual, preciseDuals); 
				hasNewColumn = LabelSettingSolveSubproblem_Child(newCols, outPut, preNode->allCols, preNode->stages, preTime, preciseDuals, SR3Duals, preNode->SR3s, rcLB, preNode->branchPatterns, true);
			g_HLACols += newCols.size();
			heuDPTime += preTime;
			g_pricingTime += preTime;
			++preCallHeuDP;

			if (g_errorControl) {//if error is encountered during the pricing
				break;
			}

			if (!hasNewColumn && !heuCG) {
				////test 
				//break;

				//call the exact pricing problem
				cout << "Call the exact DP" << endl;
				CopyInstance(g_instance, g_orgInstance);//reset the instances
				preciseDuals.clear();
				tmpDualsRec.clear();
				SR3Duals.clear();
				for (int c = 0; c < allCons.size(); ++c) {
					tmpDualsRec.push_back(allCons[c].get(GRB_DoubleAttr_Pi));//the precise dual variables
					if (c < g_instance.n_items) {
						preciseDuals.push_back(allCons[c].get(GRB_DoubleAttr_Pi));//the precise dual variables
						if (g_upper_lower_dual == 1) {
							//use truncating dual variable
							g_instance.p_ptr[c] = int(floor(g_controlNum * allCons[c].get(GRB_DoubleAttr_Pi))) * 1.0 / g_controlNum;
						}
						else if (g_upper_lower_dual == 0) {
							//use upper bound of the dual variables
							g_instance.p_ptr[c] = int(ceil(g_controlNum * allCons[c].get(GRB_DoubleAttr_Pi))) * 1.0 / g_controlNum;
						}
						else {
							//use original dual variable
							g_instance.p_ptr[c] = allCons[c].get(GRB_DoubleAttr_Pi);
						}
					}
					else {
						SR3Duals.push_back(allCons[c].get(GRB_DoubleAttr_Pi));
					}
				}
				double rcLB = 0;
				if (rootFlag)
					hasNewColumn = LabelSettingSolveSubproblem(newCols, outPut, preNode->allCols, preTime, preciseDuals, rcLB, false);
				else
					hasNewColumn = LabelSettingSolveSubproblem_Child(newCols, outPut, preNode->allCols, preNode->stages, preTime, preciseDuals, SR3Duals, preNode->SR3s, rcLB, preNode->branchPatterns, false);

				g_ELACols += newCols.size();
				exactDPTime += preTime;
				g_pricingTime += preTime;
				++preCallExactDP;
				/*if (!hasNewColumn) {
					cout << "No more columns can be added, CG is optimal!" << endl;
					break;
				}*/
				double presentRC = rcLB;
				double preObj = master.get(GRB_DoubleAttr_ObjVal);
				if (JgeTermination(presentRC, preObj, g_upper_lower_dual == 1)) {
					cout << "Premature encountered, CG is stopped!" << endl;
					break;
				}
				g_controlNum *= 10;
				g_dualBoundRoundNum += 1;
				g_maximumTimeDualBound += 100;
			}
			else if (heuCG && !hasNewColumn) {
				break;
			}

			// add new columns into the RMP
			for (auto& nc : newCols) {
				GRBVar newVar = master.addVar(0.0, 1.0, 1.0, GRB_CONTINUOUS);
				for (int j = 0; j < g_tolItemNum; ++j)
					master.chgCoeff(allCons[j], newVar, nc->itemSet[j]);  // itemSet[j] = 0/1
				//master.chgCoeff(allCons[g_tolItemNum], newVar, 1.0);  // itemSet[j] = 0/1
				colVars.push_back(newVar);
				preNode->allCols.emplace_back(nc);
			}
			++preCGiteration;
		}
		//check if the DOI columns are selected in the optimal basis
		double totalVal = 0;
		for (int i = 0; i < dualVars.size(); ++i) {
			double preColValue = dualVars[i].get(GRB_DoubleAttr_X);
			if (preColValue > EX) {
				g_reRunMPwithoutDOIs = true;
				totalVal += preColValue;
			}
		}
		if (g_reRunMPwithoutDOIs) {
			cout << "The value of DOIs in the basis is: " << totalVal << endl;
			outPut << "The value of DOIs in the basis is: " << totalVal << endl;
			//reset decimal precision control
			g_controlNum = 1000;
			g_dualBoundRoundNum = 1;
			g_maximumTimeDualBound = 300;
			ColumnGeneration(preNode, integerFlag, true, outPut);
		}

		//get the optimal lowerbound
		preLowerBound = master.get(GRB_DoubleAttr_ObjVal);
		//Get pre solution
		for (int i = 0; i < colVars.size(); ++i) {
			double preColValue = colVars[i].get(GRB_DoubleAttr_X);
			if (preColValue > EX) {
				preBestSolution.emplace_back(preNode->allCols[i]);
				preNode->preSolution.insert({ i, preColValue });
				if (preColValue < 1 - 1e-4)
					integerFlag = false;//Judge integer solution or not
			}
		}
	}
	catch (GRBException& e) {
		std::cerr << "Gurobi exception：" << e.getMessage() << std::endl;
		outPut << "Gurobi exception：" << e.getMessage() << std::endl;
		integerFlag = false;//Judge integer solution or not
	}
	catch (exception& e) {
		std::cerr << "Other excetion: " << e.what() << std::endl;
		outPut << "Other excetion: " << e.what() << std::endl;
		integerFlag = false;//Judge integer solution or not
	}

	if (integerFlag) {
		//update best upper bound and the best solution
		if (preLowerBound < g_binpackingUB) {
			g_binpackingUB = round(preLowerBound);
			CopySolution(g_bestSol_binpacking, preBestSolution);
		}
	}
	auto endTime = chrono::high_resolution_clock::now();
	cout << "Heuristic DP time is: " << heuDPTime << " s" << endl;
	cout << "Exact DP time is: " << exactDPTime << " s" << endl;
	cout << "CG time is: " << chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0 << " s" << endl;
	g_DOIsCandidates.clear();	//clear the DOIs candidates
	return preLowerBound;
}

//Conduct the column generation
double ColumnGeneration(
	BranchNode* preNode,
	bool& integerFlag,
	bool rootFlag,
	ofstream& outPut,
	bool heuCG) {
	int preCGiteration = 0;			//record the CG iteration
	int preCallHeuDP = 0;			//record the number of heuristic DP calls
	int preCallExactDP = 0;			//record the number of exact DP calls
	double heuDPTime = 0;			//time spent on the heuristic DP
	double exactDPTime = 0;			//time spent on the exact DP
	integerFlag = true;

	auto startTime = chrono::high_resolution_clock::now();
	double preLowerBound = g_tolItemNum;
	vector<Bin*> preBestSolution;
	try {
		/*setting the node*/
		GRBEnv preEnv = GRBEnv(true);
		preEnv.set(GRB_IntParam_OutputFlag, 0); // turn off the log
		preEnv.start();
		GRBModel master = GRBModel(preEnv);
		//master.set(GRB_DoubleParam_OptimalityTol, EX); //set gurobi precision
		//master.set(GRB_DoubleParam_IntFeasTol, EX);
		//master.set(GRB_DoubleParam_FeasibilityTol, EX);
		master.set(GRB_IntParam_Method, 0); //0, primal; 1 dual, 2 barrier, 3 concurrent
		vector<GRBVar> colVars;
		//add columns into RMP
		for (int i = 0; i < preNode->allCols.size(); ++i) {
			GRBVar var = master.addVar(0.0, 1.0, 1.0, GRB_CONTINUOUS);
			colVars.emplace_back(var);//record each column variable
		}
		//record all the added preCons
		vector<GRBConstr> allCons;
		//construct RMP
		CreateRMP(colVars, preNode->allCols, preNode->SR3s, allCons, master);

		/*The loop of CG*/
		while (true) {
			++g_CGIterations;
			//control the solution time
			auto endTime = chrono::high_resolution_clock::now();
			if (g_BPTime + chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0 >= MAXMUMSOLTIME) {
				g_timeLimitReach = true;
				break;
			}
			//control the heuristic CG time
			if (heuCG &&
				chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0 >= MAXMUMHEUCGTIME) {
				break;
			}

			master.optimize();
			if (master.get(GRB_IntAttr_Status) != GRB_OPTIMAL) {
				cerr << "The master problem is not solved to optimal!" << endl;
				preLowerBound = g_tolItemNum;
				break;
			}
			cout << "The present lower bound is: " << master.get(GRB_DoubleAttr_ObjVal) << endl;

			//reset the instances
			CopyInstance(g_instance, g_orgInstance);

			//get dual variables
			vector<double> preciseDuals;
			vector<double> tmpDualsRec;
			vector<double> SR3Duals;		//dual variables related to SR3s
			for (int c = 0; c < allCons.size(); ++c) {
				tmpDualsRec.push_back(allCons[c].get(GRB_DoubleAttr_Pi));//the precise dual variables
				if (c < g_instance.n_items) {
					preciseDuals.push_back(allCons[c].get(GRB_DoubleAttr_Pi));//the precise dual variables
					if (g_upper_lower_dual == 1) {
						//use truncating dual variable
						g_instance.p_ptr[c] = int(floor(g_controlNum * allCons[c].get(GRB_DoubleAttr_Pi))) * 1.0 / g_controlNum;
					}
					else if (g_upper_lower_dual == 0) {
						//use upper bound of the dual variables
						g_instance.p_ptr[c] = int(ceil(g_controlNum * allCons[c].get(GRB_DoubleAttr_Pi))) * 1.0 / g_controlNum;
					}
					else {
						//use original dual variable
						g_instance.p_ptr[c] = allCons[c].get(GRB_DoubleAttr_Pi);
					}
				}
				else {
					SR3Duals.push_back(allCons[c].get(GRB_DoubleAttr_Pi));
				}
			}

			//Solve the subproblem to generate new columns
			vector<Bin*> newCols;
			double preTime = 0;
			bool hasNewColumn = false;
			double rcLB = 0;
			if (rootFlag)
				//hasNewColumn = SolveCompactPricingModel(newCols, outPut, preNode->stages, preTime, binNumDual, preciseDuals);
				hasNewColumn = LabelSettingSolveSubproblem(newCols, outPut, preNode->allCols, preTime, preciseDuals, rcLB, true);
			else
				//hasNewColumn = SolveCompactPricingModel(newCols, outPut, preNode->stages, preTime, binNumDual, preciseDuals); 
				hasNewColumn = LabelSettingSolveSubproblem_Child(newCols, outPut, preNode->allCols, preNode->stages, preTime, preciseDuals, SR3Duals, preNode->SR3s, rcLB, preNode->branchPatterns, true);
			g_HLACols += newCols.size();
			heuDPTime += preTime;
			g_pricingTime += preTime;

			++preCallHeuDP;

			if (!hasNewColumn && !heuCG) {
				////test 
				//break;

				//call the exact pricing problem
				cout << "Call the exact DP" << endl;
				CopyInstance(g_instance, g_orgInstance);//reset the instances
				preciseDuals.clear();
				tmpDualsRec.clear();
				SR3Duals.clear();
				for (int c = 0; c < allCons.size(); ++c) {
					tmpDualsRec.push_back(allCons[c].get(GRB_DoubleAttr_Pi));//the precise dual variables
					if (c < g_instance.n_items) {
						preciseDuals.push_back(allCons[c].get(GRB_DoubleAttr_Pi));//the precise dual variables
						if (g_upper_lower_dual == 1) {
							//use truncating dual variable
							g_instance.p_ptr[c] = int(floor(g_controlNum * allCons[c].get(GRB_DoubleAttr_Pi))) * 1.0 / g_controlNum;
						}
						else if (g_upper_lower_dual == 0) {
							//use upper bound of the dual variables
							g_instance.p_ptr[c] = int(ceil(g_controlNum * allCons[c].get(GRB_DoubleAttr_Pi))) * 1.0 / g_controlNum;
						}
						else {
							//use original dual variable
							g_instance.p_ptr[c] = allCons[c].get(GRB_DoubleAttr_Pi);
						}
					}
					else {
						SR3Duals.push_back(allCons[c].get(GRB_DoubleAttr_Pi));
					}
				}
				double rcLB = 0;
				if (rootFlag)
					hasNewColumn = LabelSettingSolveSubproblem(newCols, outPut, preNode->allCols, preTime, preciseDuals, rcLB, false);
				else
					hasNewColumn = LabelSettingSolveSubproblem_Child(newCols, outPut, preNode->allCols, preNode->stages, preTime, preciseDuals, SR3Duals, preNode->SR3s, rcLB, preNode->branchPatterns, false);

				g_ELACols += newCols.size();
				exactDPTime += preTime;
				g_pricingTime += preTime;
				++preCallExactDP;
				/*if (!hasNewColumn) {
					cout << "No more columns can be added, CG is optimal!" << endl;
					break;
				}*/
				double presentRC = rcLB;
				double preObj = master.get(GRB_DoubleAttr_ObjVal);
				if (JgeTermination(presentRC, preObj, g_upper_lower_dual == 1)) {
					cout << "Premature encountered, CG is stopped!" << endl;
					break;
				}
				g_controlNum *= 10;
				g_dualBoundRoundNum += 1;
				g_maximumTimeDualBound += 100;
			}
			else if (heuCG && !hasNewColumn) {
				break;
			}

			// add new columns into the RMP
			for (auto& nc : newCols) {
				GRBVar newVar = master.addVar(0.0, 1.0, 1.0, GRB_CONTINUOUS);
				for (int j = 0; j < g_tolItemNum; ++j)
					master.chgCoeff(allCons[j], newVar, nc->itemSet[j]);  // itemSet[j] = 0/1
				//master.chgCoeff(allCons[g_tolItemNum], newVar, 1.0);  // itemSet[j] = 0/1
				colVars.push_back(newVar);
				preNode->allCols.emplace_back(nc);
			}
			++preCGiteration;
		}
		//get the optimal lowerbound
		preLowerBound = master.get(GRB_DoubleAttr_ObjVal);
		//Get pre solution
		for (int i = 0; i < colVars.size(); ++i) {
			double preColValue = colVars[i].get(GRB_DoubleAttr_X);
			if (preColValue > EX) {
				preBestSolution.emplace_back(preNode->allCols[i]);
				preNode->preSolution.insert({ i, preColValue });
				if (preColValue < 1 - 1e-4)
					integerFlag = false;//Judge integer solution or not
			}
		}
	}
	catch (GRBException& e) {
		std::cerr << "Gurobi exception：" << e.getMessage() << std::endl;
		integerFlag = false;//Judge integer solution or not
	}
	catch (exception& e) {
		std::cerr << "Other excetion: " << e.what() << std::endl;
		integerFlag = false;//Judge integer solution or not
	}

	if (integerFlag) {
		//update best upper bound and the best solution
		if (preLowerBound < g_binpackingUB) {
			g_binpackingUB = round(preLowerBound);
			CopySolution(g_bestSol_binpacking, preBestSolution);
		}
	}
	auto endTime = chrono::high_resolution_clock::now();
	cout << "Heuristic DP time is: " << heuDPTime << " s" << endl;
	cout << "Exact DP time is: " << exactDPTime << " s" << endl;
	cout << "CG time is: " << chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0 << " s" << endl;
	return preLowerBound;
}

//Free space of the BP
void FreeSpace(vector<Bin*>& rootCols) {
	//free solutions
	for (auto& e : rootCols)
		delete e;
	for (auto& e : g_bestSol_binpacking)
		delete e;
	//free instances
	free(g_orgInstance.a_ptr);
	free(g_orgInstance.b_ptr);
	free(g_orgInstance.p_ptr);
	free(g_orgInstance.p_weight);
	g_orgInstance.a_ptr = g_orgInstance.b_ptr = g_orgInstance.p_ptr = g_orgInstance.p_weight = nullptr;

}

//Judge end a node or not
bool JgeRootNodeEnd(
	double& lowerBound,
	vector<Bin*>& preCols,
	ofstream& outPut,
	bool integerFlag) {
	//judge premature termination rules
	if (int(ceil(lowerBound)) == g_binpackingUB) {
		FreeSpace(preCols);
		cout << "No branches is needed and the best solution use " << g_binpackingUB << " bins!" << endl;
		outPut << "No branches is needed and the best solution use " << g_binpackingUB << " bins!" << endl;
		return true;
	}

	//Judge the integer solution of the present node
	if (integerFlag) {
		FreeSpace(preCols);
		cout << "No branches is needed and the best solution use " << g_binpackingUB << " bins!" << endl;
		outPut << "No branches is needed and the best solution use " << g_binpackingUB << " bins!" << endl;
		return true;
	}
	return false;
}

//choose a branch bin num
bool ChooseBranchBinNum(
	double& preLowerBound,
	pair<int, int>& preBinRange,
	int& chosenBranchPattern
) {
	//test mask branch bin num
	return false;

	double useBinNum = preLowerBound;
	if (useBinNum - floor(useBinNum + EX) > EX) {//could use bin num branch
		int preBranchNum = int(floor(useBinNum + EX));
		if (preBranchNum < preBinRange.first || preBranchNum > preBinRange.second) {
			if (abs(preBranchNum - preBinRange.first) <= EX ||
				abs(preBranchNum - preBinRange.second) <= EX) {
				chosenBranchPattern = preBranchNum;
				return true;
			}
		}
		chosenBranchPattern = preBranchNum;
		return true;
	}
	return false;
}

//choose a branch pattern
bool ChooseBranchPattern(
	unordered_map<int, double>& preSolution,
	vector<Bin*>& preCols,
	unordered_map<int, BranchPattern>& branchPatterns,
	BranchPattern& bestPattern
) {
	//mask
	return false;

	bool findFlag = false;
	unordered_map<int, BranchPattern> rec;
	for (auto& solVal : preSolution) {
		if (solVal.second > EX && solVal.second < 1 - EX) {
			for (int j = 0; j < preCols[solVal.first]->itemSet.size(); ++j) {
				if (preCols[solVal.first]->itemSet[j]) {
					if (rec.count(j)) {
						if (preCols[solVal.first]->tolWeight < rec[j].branchRange.first)
							rec[j].branchRange.first = preCols[solVal.first]->tolWeight;
						else if (preCols[solVal.first]->tolWeight > rec[j].branchRange.second)
							rec[j].branchRange.second = preCols[solVal.first]->tolWeight;
						++rec[j].existCols;
					}
					else {
						rec[j].branchItem = j;
						rec[j].branchRange = { preCols[solVal.first]->tolWeight , preCols[solVal.first]->tolWeight };
						++rec[j].existCols;
					}
				}
			}
		}
	}

	double minRange = 1e10;	//the minimum weight range
	auto ite = rec.begin();
	while (ite != rec.end()) {
		if (ite->second.existCols > 1 &&
			ite->second.branchRange.second - ite->second.branchRange.first < minRange) {
			minRange = ite->second.branchRange.second - ite->second.branchRange.first;
			auto thisIte = branchPatterns.find(ite->first);
			if (thisIte != branchPatterns.end()) {//update weight range
				//the following range should be smaller than the formal one
				//thisIte->second.branchRange = ite->second.branchRange;
			}
			bestPattern = ite->second;
			findFlag = true;
		}
		++ite;
	}
	return findFlag;
}

//choose a branch item pair
struct pair_hash {
	std::size_t operator()(const std::pair<int, int>& p) const {
		return std::hash<int>()(p.first) ^ (std::hash<int>()(p.second) << 1);
	}
};
void ChooseBranchItemPair(
	unordered_map<int, double>& preSolution,
	vector<Bin*>& preCols,
	const vector<BranchInfo>& branchArcs,
	vector<std::unordered_set<int>> SR3s,
	pair<int, int>& bestPair) {
	unordered_map<pair<int, int>, double, pair_hash> rec;
	unordered_map<pair<int, int>, double, pair_hash> sr3Rec;
	for (auto& solVal : preSolution) {
		if (solVal.second > EX && solVal.second < 1 - EX) {
			for (int j = 0; j < preCols[solVal.first]->itemSet.size(); ++j) {
				if (preCols[solVal.first]->itemSet[j]) {
					for (int k = j + 1; k < preCols[solVal.first]->itemSet.size(); ++k) {
						if (preCols[solVal.first]->itemSet[k])
							rec[{j, k}] += solVal.second;
					}
				}
			}
		}
	}
	//try to choose a branch arc contained in the same SR3, to reduce overlap of stages
	for (auto& arc : rec) {
		for (auto& sr3 : SR3s) {
			if (sr3.find(arc.first.first) != sr3.end() &&
				sr3.find(arc.first.second) != sr3.end()) {
				sr3Rec[arc.first] = arc.second;
			}
		}
	}
	double bestDistance = 1;
	bool chooseFlag = false;
	for (auto& ite : sr3Rec) {
		if (!(ite.second < 1 - EX && ite.second > 0 + EX))
			continue;
		double preDistance = abs(ite.second - 0.5);
		if (preDistance < bestDistance) {
			bestDistance = preDistance;
			bestPair = ite.first;
			chooseFlag = true;
		}
	}
	if (chooseFlag) return;

	//Then try to get a branch item not overlap with the formal branches
	unordered_set<int> formalItems;
	for (auto& e : branchArcs) {
		formalItems.insert(e.itemPair.first);
		formalItems.insert(e.itemPair.second);
	}
	bestDistance = 1;
	chooseFlag = false;
	for (auto& ite : rec) {
		double preDistance = abs(ite.second - 0.5);
		if (preDistance < bestDistance
			&& formalItems.find(ite.first.first) == formalItems.end()
			&& formalItems.find(ite.first.second) == formalItems.end()
			) {
			bestDistance = preDistance;
			bestPair = ite.first;
			chooseFlag = true;
		}
	}
	if (chooseFlag) return;

	//Finally, get the best branch item pair from the rest arc pairs
	bestDistance = 1;
	for (auto& ite : rec) {
		double preDistance = abs(ite.second - 0.5);
		if (preDistance < bestDistance) {
			bestDistance = preDistance;
			bestPair = ite.first;
		}
	}
}

// judge separation constraints
bool IsValidCombination(std::vector<int>& combination,
	const std::unordered_map<int, std::vector<int>>& separationPairs) {
	std::unordered_set<int> itemSet(combination.begin(), combination.end());

	for (int item : combination) {
		if (separationPairs.count(item)) {
			for (int conflictItem : separationPairs.at(item)) {
				if (itemSet.count(conflictItem)) {
					return false; // violate separation constraints
				}
			}
		}
	}
	combination = vector<int>(itemSet.begin(), itemSet.end());
	sort(combination.begin(), combination.end());
	return true;
}
//enumerate valid operations
bool EnumerateValidCombinations(
	const std::vector<int>& candidates,
	const Stage& preSg,
	std::vector<std::vector<int>>& results) {
	auto startTime = chrono::high_resolution_clock::now();

	int n = candidates.size();
	// enumerate all the subset
	for (int mask = 0; mask < (1 << n); ++mask) {
		std::vector<int> combination;
		for (int i = 0; i < n; ++i) {
			if (mask & (1 << i)) {
				combination.push_back(candidates[i]);
			}
		}
		if (!combination.empty()) {
			vector<int> tCom = combination;
			//consider together set
			for (auto& e : combination) {
				if (preSg.stageCandidates.count(e) &&
					preSg.stageCandidates.at(e) != -1)
					tCom.insert(tCom.end(),
						preSg.togetherSet[preSg.stageCandidates.at(e)].begin(),
						preSg.togetherSet[preSg.stageCandidates.at(e)].end());
			}
			if (IsValidCombination(tCom, preSg.separationPairs)) {
				if (find(results.begin(), results.end(), tCom) == results.end())
					results.push_back(tCom);
			}

			//control solution time
			auto endTime = chrono::high_resolution_clock::now();
			if (g_BPTime
				+ chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0
		> MAXMUMSOLTIME) {
				return false;
			}
		}
	}
	return true;
}

//adjust Stages when adding new SR3s
void SR3Stages(
	vector<unordered_set<int>> newSR3s,
	vector<unordered_set<int>> allSR3s,
	vector<Stage>& preStages
) {
	//add all sr3 into the stages
	for (auto& sr3 : newSR3s) {
		int firstNode = *sr3.begin();
		int secondNode = *(++sr3.begin());
		int thirdNode = *(++(++(sr3.begin())));
		if (preStages.empty()) {
			Stage preStage = Stage();
			preStage.stageCandidates.insert({ firstNode, -1 });
			preStage.stageCandidates.insert({ secondNode, -1 });
			preStage.stageCandidates.insert({ thirdNode, -1 });
			preStage.separationPairs.insert({ firstNode, {} });
			preStage.separationPairs.insert({ secondNode, {} });
			preStage.separationPairs.insert({ thirdNode, {} });
			preStages.emplace_back(preStage);
		}
		else {//find if the present sr3 is overlapped with formal stages, cause we don't generate overlaped sr3s, it can only overlap with some branches stages
			bool findFlag = false;
			Stage& resSg = *preStages.begin();
			for (auto& sg : preStages) {
				auto ite = sg.stageCandidates.find(firstNode);
				if (ite == sg.stageCandidates.end()) {
					ite = sg.stageCandidates.find(secondNode);
					if (ite == sg.stageCandidates.end()) {
						ite = sg.stageCandidates.find(thirdNode);
						if (ite != sg.stageCandidates.end()) {
							findFlag = true;
							resSg = sg;
							break;
						}
					}
					else {
						findFlag = true;
						resSg = sg;
						break;
					}
				}
				else {
					findFlag = true;
					resSg = sg;
					break;
				}
			}
			if (findFlag) {//overlap
				if (resSg.stageCandidates.find(firstNode) == resSg.stageCandidates.end()) {
					resSg.stageCandidates.insert({ firstNode, -1 });
					resSg.separationPairs.insert({ firstNode, {} });
				}
				if (resSg.stageCandidates.find(secondNode) == resSg.stageCandidates.end()) {
					resSg.stageCandidates.insert({ secondNode, -1 });
					resSg.separationPairs.insert({ secondNode, {} });
				}
				if (resSg.stageCandidates.find(thirdNode) == resSg.stageCandidates.end()) {
					resSg.stageCandidates.insert({ thirdNode, -1 });
					resSg.separationPairs.insert({ thirdNode, {} });
				}
			}
			else {//non-overlap
				Stage preStage = Stage();
				preStage.stageCandidates.insert({ firstNode, -1 });
				preStage.stageCandidates.insert({ secondNode, -1 });
				preStage.stageCandidates.insert({ thirdNode, -1 });
				preStage.separationPairs.insert({ firstNode, {} });
				preStage.separationPairs.insert({ secondNode, {} });
				preStage.separationPairs.insert({ thirdNode, {} });
				preStages.emplace_back(preStage);
			}
		}
	}

	//merge stages with same candidates
	for (int i = 0; i < preStages.size(); ++i) {
		for (int j = i + 1; j < preStages.size(); ++j) {
			// find duplicated items
			std::vector<int> intersection;
			const std::unordered_map<int, int>& smaller = (preStages[i].stageCandidates.size() < preStages[j].stageCandidates.size()) ? preStages[i].stageCandidates : preStages[j].stageCandidates;
			const std::unordered_map<int, int>& larger = (preStages[i].stageCandidates.size() < preStages[j].stageCandidates.size()) ? preStages[j].stageCandidates : preStages[i].stageCandidates;
			for (auto& val : smaller) {
				if (larger.count(val.first))
					intersection.push_back(val.first);
			}
			if (!intersection.empty()) {
				//merge stage j into stage j
				for (auto& e : intersection) {
					//merge together set
					int tgtIdx1 = preStages[i].stageCandidates[e];
					if (tgtIdx1 != -1) {
						int tgtIdx2 = preStages[j].stageCandidates[e];
						if (tgtIdx2 != -1 && tgtIdx2 < 10000) {
							for (auto& e1 : preStages[j].togetherSet[tgtIdx2]) {
								if (e1 != e) {
									preStages[i].togetherSet[tgtIdx1].push_back(e1);
									preStages[j].stageCandidates[e1] = 10000 + tgtIdx1;
								}
							}
						}
					}
					else {
						if (preStages[j].stageCandidates[e] != -1)
							preStages[i].stageCandidates[e] =
							preStages[j].stageCandidates[e] + preStages[i].togetherSet.size();
					}
					//merge separation set
					if (preStages[j].separationPairs.count(e))
						preStages[i].separationPairs[e].insert(preStages[i].separationPairs[e].end(), preStages[j].separationPairs[e].begin(), preStages[j].separationPairs[e].end());
					//delete e from preStages[j]
					preStages[j].stageCandidates.erase(e);
				}
				//add other candidates stage j into stage j
				for (auto& e : preStages[j].stageCandidates) {
					if (e.second != -1) {
						if (e.second < 10000)
							e.second += preStages[i].togetherSet.size();
						else
							e.second -= 10000;
					}
					preStages[i].stageCandidates.insert(e);
					if (preStages[j].separationPairs.count(e.first))
						preStages[i].separationPairs.insert({ e.first, preStages[j].separationPairs[e.first] });
				}
				preStages[i].togetherSet.insert(preStages[i].togetherSet.end(), preStages[j].togetherSet.begin(), preStages[j].togetherSet.end());
				preStages.erase(preStages.begin() + j);
				--j;
			}
		}

	}

	//adjust stages operations
	for (auto& sg : preStages) {
		//get all the separation candidates
		unordered_set<int> separationCandidates;
		for (auto& e : sg.separationPairs) {
			separationCandidates.insert(e.first);
			for (auto& t : e.second)
				separationCandidates.insert(t);
		}
		vector<int> candidates(separationCandidates.begin(), separationCandidates.end());
		sg.options.clear();
		sg.SR3Dual.clear();
		//get all the feasibility operations, exclude the operation forbidaned by the separation separationPairs
		if (!EnumerateValidCombinations(candidates, sg, sg.options)) {
			g_timeLimitReach = true;
			return;
		}
		if (sg.options.empty())//if no separation set
			sg.options = sg.togetherSet;
		sg.SR3Dual.resize(sg.options.size());
		//add SR3Dual according to the options generated
		for (int i = 0; i < sg.options.size(); ++i) {
			unordered_set<int> tOption(sg.options[i].begin(), sg.options[i].end());
			for (int j = 0; j < allSR3s.size(); ++j) {
				//Find intersection of two sets
				std::unordered_set<int> intersection;
				if (tOption.size() < allSR3s[j].size()) {
					for (const int& elem : tOption) {
						if (allSR3s[j].count(elem)) {
							intersection.insert(elem);
							if (intersection.size() >= 2) break;
						}
					}
				}
				else {
					for (const int& elem : allSR3s[j]) {
						if (tOption.count(elem)) {
							intersection.insert(elem);
							if (intersection.size() >= 2) break;
						}
					}
				}
				if (intersection.size() >= 2)
					sg.SR3Dual[i].push_back(j);//the dual variable of j SR3 should be considered in option i
			}
		}
	}
}

//adjust Stages in the child nodes when branching
void AdjustStages(
	BranchInfo& preBranchArc,
	vector<unordered_set<int>> preSR3s,
	vector<Stage>& preStages
) {
	//adjust basic informations
	if (preBranchArc.same_diff == 0) {//same branch, only need to adjust separation candidates and together set, no need to change operations
		if (preStages.empty()) {
			Stage preStage = Stage();
			preStage.stageCandidates.insert({ preBranchArc.itemPair.first, 0 });
			preStage.stageCandidates.insert({ preBranchArc.itemPair.second, 0 });
			preStage.togetherSet.emplace_back(vector<int>(1, preBranchArc.itemPair.first));
			preStage.togetherSet.back().push_back(preBranchArc.itemPair.second);
			preStages.emplace_back(preStage);
		}
		else {
			//find if the items in preBranchInfo is contained in stageCandidates or together set
			bool findFlag = false;
			for (auto& sg : preStages) {
				auto ite1 = sg.stageCandidates.find(preBranchArc.itemPair.first);
				if (ite1 == sg.stageCandidates.end()) {
					//preBranchInfo.itemPair.first does not exist
					auto ite2 = sg.stageCandidates.find(preBranchArc.itemPair.second);
					if (ite2 != sg.stageCandidates.end()) {
						if (ite2->second != -1)
							sg.togetherSet[ite2->second].push_back(preBranchArc.itemPair.first);
						else {
							sg.togetherSet.push_back(vector<int>(1, ite2->first));
							sg.togetherSet.back().push_back(preBranchArc.itemPair.first);
							ite2->second = sg.togetherSet.size() - 1;
						}
						sg.stageCandidates.insert({ preBranchArc.itemPair.first, ite2->second });
						findFlag = true;
						break;
					}

				}
				else {
					if (ite1->second != -1)
						sg.togetherSet[ite1->second].push_back(preBranchArc.itemPair.second);
					else {
						sg.togetherSet.push_back(vector<int>(1, ite1->first));
						sg.togetherSet.back().push_back(preBranchArc.itemPair.second);
						ite1->second = sg.togetherSet.size() - 1;
						auto ite2 = sg.stageCandidates.find(preBranchArc.itemPair.second);
						if (ite2 != sg.stageCandidates.end() &&
							ite2->second == -1)
							ite2->second = sg.togetherSet.size() - 1;
					}
					//judge if there a need to merge two together set
					auto ite2 = sg.stageCandidates.find(preBranchArc.itemPair.second);
					if (ite2 != sg.stageCandidates.end()) {
						if (ite2->second != -1 && ite2->second != ite1->second) {
							//merge two together set
							auto& tIte1 = ite1->second > ite2->second ? ite2 : ite1;//with small index
							auto& tIte2 = ite1->second > ite2->second ? ite1 : ite2;
							int largeIdx = tIte2->second;
							unordered_set<int>tmp(sg.togetherSet[tIte1->second].begin(), sg.togetherSet[tIte1->second].end());
							tmp.insert(sg.togetherSet[tIte2->second].begin(), sg.togetherSet[tIte2->second].end());
							sg.togetherSet[tIte1->second] = vector<int>(tmp.begin(), tmp.end());
							for (auto& elem : sg.togetherSet[tIte2->second])
								sg.stageCandidates[elem] = tIte1->second;
							sg.togetherSet.erase(sg.togetherSet.begin() + largeIdx);
						}
					}
					else
						sg.stageCandidates.insert({ preBranchArc.itemPair.second, ite1->second });
					findFlag = true;
					break;
				}
			}
			if (!findFlag) {//create a new stage
				Stage preStage = Stage();
				preStage.stageCandidates.insert({ preBranchArc.itemPair.first, 0 });
				preStage.stageCandidates.insert({ preBranchArc.itemPair.second, 0 });
				preStage.togetherSet.emplace_back(vector<int>(1, preBranchArc.itemPair.first));
				preStage.togetherSet.back().push_back(preBranchArc.itemPair.second);
				preStages.emplace_back(preStage);
			}
		}
	}
	else {//different branch, need to adjust separationcandidates, and separation pairs
		if (preStages.empty()) {
			Stage preStage = Stage();
			preStage.stageCandidates.insert({ preBranchArc.itemPair.first , -1 });
			preStage.stageCandidates.insert({ preBranchArc.itemPair.second, -1 });
			preStage.separationPairs[preBranchArc.itemPair.first].push_back(preBranchArc.itemPair.second);;
			preStages.emplace_back(preStage);
		}
		else {
			//find if the items in preBranchInfo is contained in stageCandidates or together set
			bool findFlag = false;
			for (auto& sg : preStages) {
				auto ite1 = sg.stageCandidates.find(preBranchArc.itemPair.first);
				if (ite1 == sg.stageCandidates.end()) {
					//preBranchInfo.itemPair.first does not exist
					auto ite2 = sg.stageCandidates.find(preBranchArc.itemPair.second);
					if (ite2 != sg.stageCandidates.end()) {
						sg.separationPairs[preBranchArc.itemPair.first].push_back(preBranchArc.itemPair.second);
						sg.stageCandidates.insert({ preBranchArc.itemPair.first, -1 });
						findFlag = true;
						break;
					}
				}
				else {
					sg.separationPairs[preBranchArc.itemPair.first].push_back(preBranchArc.itemPair.second);
					//find preBranchInfo.itemPair.second
					auto ite2 = sg.stageCandidates.find(preBranchArc.itemPair.second);
					if (ite2 == sg.stageCandidates.end()) {
						sg.stageCandidates.insert({ preBranchArc.itemPair.second, -1 });
					}
					findFlag = true;
					break;
				}
			}
			if (!findFlag) {//create a new stage
				Stage preStage = Stage();
				preStage.stageCandidates.insert({ preBranchArc.itemPair.first , -1 });
				preStage.stageCandidates.insert({ preBranchArc.itemPair.second, -1 });
				preStage.separationPairs[preBranchArc.itemPair.first].push_back(preBranchArc.itemPair.second);;
				preStages.emplace_back(preStage);
			}
		}
	}

	////test
	//for (auto& sg : preStages) {
	//	for (auto& e : sg.separationPairs) {
	//		if (e.second.empty()) {
	//			int a = 0;
	//			cout << "error here!" << endl;
	//		}
	//	}
	//}

	//merge stages with same candidates
	for (int i = 0; i < preStages.size(); ++i) {
		for (int j = i + 1; j < preStages.size(); ++j) {
			// find duplicated items
			std::vector<int> intersection;
			const std::unordered_map<int, int>& smaller = (preStages[i].stageCandidates.size() < preStages[j].stageCandidates.size()) ? preStages[i].stageCandidates : preStages[j].stageCandidates;
			const std::unordered_map<int, int>& larger = (preStages[i].stageCandidates.size() < preStages[j].stageCandidates.size()) ? preStages[j].stageCandidates : preStages[i].stageCandidates;
			for (auto& val : smaller) {
				if (larger.count(val.first))
					intersection.push_back(val.first);
			}
			if (!intersection.empty()) { //at most one item
				//merge stage j into stage j
				for (auto& e : intersection) {
					//merge together set
					int tgtIdx1 = preStages[i].stageCandidates[e];
					if (tgtIdx1 != -1) {
						int tgtIdx2 = preStages[j].stageCandidates[e];
						if (tgtIdx2 != -1) {
							for (auto& e1 : preStages[j].togetherSet[tgtIdx2]) {
								if (e1 != e) {
									preStages[i].togetherSet[tgtIdx1].push_back(e1);
									preStages[j].stageCandidates[e1] = 10000 + tgtIdx1;
								}
							}
						}
					}
					else {
						if (preStages[j].stageCandidates[e] != -1)
							preStages[i].stageCandidates[e] =
							preStages[j].stageCandidates[e] + preStages[i].togetherSet.size();
					}
					//merge separation set
					if (preStages[j].separationPairs.count(e))
						preStages[i].separationPairs[e].insert(preStages[i].separationPairs[e].end(), preStages[j].separationPairs[e].begin(), preStages[j].separationPairs[e].end());
					//delete e from preStages[j]
					preStages[j].stageCandidates.erase(e);
				}
				//add other candidates stage j into stage j
				for (auto& e : preStages[j].stageCandidates) {
					if (e.second != -1) {
						if (e.second < 10000)
							e.second += preStages[i].togetherSet.size();
						else
							e.second -= 10000;
					}
					preStages[i].stageCandidates.insert(e);
					if (preStages[j].separationPairs.count(e.first))
						preStages[i].separationPairs.insert({ e.first, preStages[j].separationPairs[e.first] });
				}
				preStages[i].togetherSet.insert(preStages[i].togetherSet.end(), preStages[j].togetherSet.begin(), preStages[j].togetherSet.end());
				preStages.erase(preStages.begin() + j);
				--j;
			}
		}

	}

	//adjust stages operations
	for (auto& sg : preStages) {
		//get all the separation candidates
		unordered_set<int> separationCandidates;
		unordered_set<int> toghtherSets;
		for (auto& e : sg.separationPairs) {
			separationCandidates.insert(e.first);
			for (auto& t : e.second)
				separationCandidates.insert(t);
			/*if (!toghtherSets.count(sg.stageCandidates[e.first])) {
				separationCandidates.insert(e.first);
				if (sg.stageCandidates[e.first] > 0)
					toghtherSets.insert(sg.stageCandidates[e.first]);
			}
			for (auto& t : e.second) {
				if (!toghtherSets.count(sg.stageCandidates[t])) {
					separationCandidates.insert(t);
					if (sg.stageCandidates[t] > 0)
						toghtherSets.insert(sg.stageCandidates[t]);
				}
			}*/
		}
		vector<int> candidates(separationCandidates.begin(), separationCandidates.end());
		sg.options.clear();
		sg.SR3Dual.clear();
		//add all together only opterations
		//sg.options = sg.togetherSet;
		//get all the feasibility operations, exclude the operation forbidaned by the separation separationPairs
		if (!EnumerateValidCombinations(candidates, sg, sg.options)) {
			g_timeLimitReach = true;
			return;
		}
		if (sg.options.empty())//if no separation set
			sg.options = sg.togetherSet;
		sg.SR3Dual.resize(sg.options.size());
		//add SR3Dual according to the options generated
		for (int i = 0; i < sg.options.size(); ++i) {
			unordered_set<int> tOption(sg.options[i].begin(), sg.options[i].end());
			for (int j = 0; j < preSR3s.size(); ++j) {
				//Find intersection of two sets
				std::unordered_set<int> intersection;
				if (tOption.size() < preSR3s[j].size()) {
					for (const int& elem : tOption) {
						if (preSR3s[j].count(elem)) {
							intersection.insert(elem);
							if (intersection.size() >= 2) break;
						}
					}
				}
				else {
					for (const int& elem : preSR3s[j]) {
						if (tOption.count(elem)) {
							intersection.insert(elem);
							if (intersection.size() >= 2) break;
						}
					}
				}
				if (intersection.size() >= 2)
					sg.SR3Dual[i].push_back(j);//the dual variable of j SR3 should be considered in Stage i
			}
		}
	}
}

//create two child nodes
void CreateTwoChildNodes(
	BranchNode* parentNode,
	bool chosenBranchPattern,
	BranchInfo& preBranchArc,
	stack<BranchNode*>& allNodes,
	ofstream& outPut
) {
	//inherit information from parent node
	BranchNode* child1 = new BranchNode(parentNode);
	BranchNode* child2 = new BranchNode(parentNode);
	//update the maximum node depth and the sum of node depth
	g_maxNodeDepth = max(g_maxNodeDepth, parentNode->nodeDepth + 1);
	g_nodeDepthSum += 2 * (parentNode->nodeDepth + 1);

	/*branch on pattern*/
	if (chosenBranchPattern) {
		child1->branchPatterns[preBranchArc.prePattern.branchItem] = preBranchArc.prePattern;
		child2->branchPatterns[preBranchArc.prePattern.branchItem] = preBranchArc.prePattern;
		//divide the weight range equally
		double weightGap = preBranchArc.prePattern.branchRange.second - preBranchArc.prePattern.branchRange.first;
		//adjust weight range
		child1->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.first = parentNode->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.first;//left close and right open
		child1->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.second = preBranchArc.prePattern.branchRange.first + weightGap / 2;//left close and right open
		child2->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.first = preBranchArc.prePattern.branchRange.first + weightGap / 2; //left close and right close
		child2->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.second = parentNode->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.second; //left close and right close
		//adjust columns according to branch patterns
		for (int i = 0; i < child1->allCols.size(); ++i) {
			if (
				child1->allCols[i]->itemSet[preBranchArc.prePattern.branchItem]
				&&
				(child1->allCols[i]->tolWeight < child1->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.first - EX ||
					child1->allCols[i]->tolWeight > child1->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.second + EX)
				) {
				delete child1->allCols[i];
				child1->allCols.erase(child1->allCols.begin() + i);
				--i;
			}
		}
		for (int i = 0; i < child2->allCols.size(); ++i) {
			if (
				child2->allCols[i]->itemSet[preBranchArc.prePattern.branchItem]
				&&
				(child2->allCols[i]->tolWeight < child2->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.first - EX ||
					child2->allCols[i]->tolWeight > child2->branchPatterns[preBranchArc.prePattern.branchItem].branchRange.second + EX)
				) {
				delete child2->allCols[i];
				child2->allCols.erase(child2->allCols.begin() + i);
				--i;
			}
		}
	}
	/*branch on arcs*/
	else {
		//record branch arcs
		child1->branchArcs.emplace_back(preBranchArc);
		child1->branchArcs.back().same_diff = 0;		//same branch
		child2->branchArcs.emplace_back(preBranchArc);
		child2->branchArcs.back().same_diff = 1;		//different branch
		//adjust columns according to branch arcs
		for (int i = 0; i < child1->allCols.size(); ++i) {
			if (
				(child1->allCols[i]->itemSet[preBranchArc.itemPair.first] && !child1->allCols[i]->itemSet[preBranchArc.itemPair.second]) ||
				(!child1->allCols[i]->itemSet[preBranchArc.itemPair.first] && child1->allCols[i]->itemSet[preBranchArc.itemPair.second])
				) {
				delete child1->allCols[i];
				child1->allCols.erase(child1->allCols.begin() + i);
				--i;
			}
		}
		for (int i = 0; i < child2->allCols.size(); ++i) {
			if (
				child2->allCols[i]->itemSet[preBranchArc.itemPair.first] && child2->allCols[i]->itemSet[preBranchArc.itemPair.second]
				) {
				delete child2->allCols[i];
				child2->allCols.erase(child2->allCols.begin() + i);
				--i;
			}
		}
		//obtain stages according to branch records for each child nodes
		auto startTime = chrono::high_resolution_clock::now();
		AdjustStages(child1->branchArcs.back(), child1->SR3s, child1->stages);
		if (g_timeLimitReach) {
			delete child1;
			delete child2;
			return;
		}
		AdjustStages(child2->branchArcs.back(), child2->SR3s, child2->stages);
		if (g_timeLimitReach) {
			delete child1;
			delete child2;
			return;
		}
		auto endTime = chrono::high_resolution_clock::now();
		g_adjustStagesTime += chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0;
	}


	//call the column generation with adjusted DP to solve each node
	bool integerFLag1 = false, integerFLag2 = false;
	ofstream tmpOutput1, tmpOutput2;
	double lowerBound1 = ColumnGeneration(child1, integerFLag1, false, tmpOutput1);
	double lowerBound2 = ColumnGeneration(child2, integerFLag2, false, tmpOutput2);
	child1->lowerBound = lowerBound1;
	child2->lowerBound = lowerBound2;
	if (lowerBound1 < g_tolItemNum)
		g_worstDual = max(g_worstDual, lowerBound1);
	if (lowerBound2 < g_tolItemNum)
		g_worstDual = max(g_worstDual, lowerBound2);

	//the node with larger lowerbound is pushed firstly and search later, always keep child1 with larger lowerbound
	if (lowerBound1 < lowerBound2) {
		swap(child1, child2);//push the node with larger lower bound, and search the node with smaller lower bound firstly
		swap(integerFLag1, integerFLag2);
	}
	if (integerFLag1 || child1->lowerBound + 1 >= g_binpackingUB + EX)
		delete child1;
	else {
		//conduct the columns and cuts generation
		vector<unordered_set<int>> newAddedSR3s;
		SeparateSR3(child1->preSolution, child1->allCols, child1->SR3s, newAddedSR3s);
		/*If the SR3 are separeted successfully, then do the columns and cuts generation procedure*/
		bool closeFlag = false;
		if (!newAddedSR3s.empty())
			closeFlag = ColumnAndCutsGeneration(newAddedSR3s, child1, outPut);
		if (!closeFlag)
			allNodes.emplace(child1);
		else
			delete child1;
	}
	if (integerFLag2 || child2->lowerBound + 1 >= g_binpackingUB + EX)
		delete child2;
	else {
		//conduct the columns and cuts generation
		vector<unordered_set<int>> newAddedSR3s;
		SeparateSR3(child2->preSolution, child2->allCols, child2->SR3s, newAddedSR3s);
		/*If the SR3 are separeted successfully, then do the columns and cuts generation procedure*/
		bool closeFlag = false;
		if (!newAddedSR3s.empty())
			closeFlag = ColumnAndCutsGeneration(newAddedSR3s, child2, outPut);
		if (!closeFlag)
			allNodes.emplace(child2);
		else
			delete child2;
	}

	//cout << lowerBound1 << endl << lowerBound2 << endl;
}

//call MIP for a node
void CallMIPtoSolve(BranchNode* preNode) {
	//create a new node
	BranchNode* tmpNode = new BranchNode(preNode);
	//remove the columns in the tmpNode, remain only the columns with weight close to the capacity of the bin
	for (int i = 0; i < tmpNode->allCols.size(); ++i) {
		if (tmpNode->allCols[i]->tolWeight < g_instance.capacity * 0.98) {
			delete tmpNode->allCols[i];
			tmpNode->allCols.erase(tmpNode->allCols.begin() + i);
			--i;
		}
	}

	try {
		/*setting the node*/
		GRBEnv preEnv = GRBEnv(true);
		preEnv.set(GRB_IntParam_OutputFlag, 0); // turn off the log
		preEnv.start();
		GRBModel master = GRBModel(preEnv);
		vector<GRBVar> colVars;
		//add columns into RMP
		for (int i = 0; i < tmpNode->allCols.size(); ++i) {
			GRBVar var = master.addVar(0.0, 1.0, 1.0, GRB_BINARY);
			colVars.emplace_back(var);//record each column variable
		}
		//record all the added preCons
		vector<GRBConstr> allCons;
		//construct RMP
		CreateRMP(colVars, tmpNode->allCols, tmpNode->SR3s, allCons, master);
		master.getEnv().set(GRB_DoubleParam_TimeLimit, g_MIPMaxTime);//set the maximum soltuion time

		master.optimize();//solve MIP
		if (master.get(GRB_IntAttr_SolCount) == 0) {
			cout << "No feasible solutions found!" << endl;
			return;
		}

		//get the present upper bound
		double preUB = master.get(GRB_DoubleAttr_ObjVal);
		if (preUB < g_binpackingUB) {
			cout << "Call MIP finds better upper bound!" << endl;
			g_binpackingUB = round(preUB);
			vector<Bin*> preBestSolution;
			//Get pre solution
			for (int i = 0; i < colVars.size(); ++i)
				preBestSolution.emplace_back(tmpNode->allCols[i]);
			CopySolution(g_bestSol_binpacking, preBestSolution);
		}
	}
	catch (GRBException& e) {
		std::cerr << "Gurobi exception：" << e.getMessage() << std::endl;
	}
	catch (exception& e) {
		std::cerr << "Other excetion: " << e.what() << std::endl;
	}
	delete tmpNode;
}

/*separate subset row inequalities*/
void GetAllPermutation(Instance& preInstance) {
	vector<int> elements(preInstance.n_items);
	for (int i = 0; i < preInstance.n_items; ++i)
		elements[i] = i;

	vector<bool> select(preInstance.n_items, false);
	fill(select.end() - 3, select.end(), true);

	int count = 0;
	do {
		vector<int> combination;
		for (int i = 0; i < preInstance.n_items; ++i) {
			if (select[i])
				combination.push_back(elements[i]);
		}
		if (g_allSR3Comb.size() >= g_maxNumSR3Comb)
			break;
		//Fill the candidates set
		g_allSR3Comb.push_back({ combination[0] , combination[1], combination[2] });
		++count;
	} while (std::next_permutation(select.begin(), select.end()));
	cout << "Total candidates number is " << count << endl;
}
void SeparateSR3(
	unordered_map<int, double>& preSolution,
	vector<Bin*>& preCols,
	vector<unordered_set<int>>& preSR3s,
	vector<unordered_set<int>>& newSR3s
) {
	map<double, unordered_set<int>, greater<double>> candidateSR3s;
	for (auto& SR3 : g_allSR3Comb) {
		double preSumVal = 0;
		for (auto& sol : preSolution) {
			if (
				(preCols[sol.first]->itemSet[SR3[0]] && preCols[sol.first]->itemSet[SR3[1]]) ||
				(preCols[sol.first]->itemSet[SR3[0]] && preCols[sol.first]->itemSet[SR3[2]]) ||
				(preCols[sol.first]->itemSet[SR3[1]] && preCols[sol.first]->itemSet[SR3[2]])
				)
				preSumVal += sol.second;
		}
		if (preSumVal > 1 + EX) {
			auto tSR3 = unordered_set<int>(SR3.begin(), SR3.end());
			//record all the violated SR3s
			candidateSR3s.insert({ preSumVal - 1.0, tSR3 });
		}
	}
	//choose the most violated SR3s
	for (auto& candiSR3 : candidateSR3s) {
		if (preSR3s.empty()) {
			preSR3s.emplace_back(candiSR3.second);
			newSR3s.emplace_back(candiSR3.second);
			++g_SR3Num;
		}
		else {
			//check overlap of SR3s
			bool overLapFlag = false;
			for (auto& sr3 : preSR3s) {
				const std::unordered_set<int>& small = (sr3.size() < candiSR3.second.size()) ? sr3 : candiSR3.second;
				const std::unordered_set<int>& large = (sr3.size() < candiSR3.second.size()) ? candiSR3.second : sr3;
				for (const int& elem : small) {
					if (large.count(elem)) {
						overLapFlag = true;  //have overlap element
						break;
					}
				}
			}
			if (!overLapFlag) {
				preSR3s.emplace_back(candiSR3.second);
				newSR3s.emplace_back(candiSR3.second);
				++g_SR3Num;
			}
		}
	}
}

/*Columns and cuts generation procedure*/
bool ColumnAndCutsGeneration(
	vector<unordered_set<int>>& newAddedSR3s,
	BranchNode* preNode,
	ofstream& outPut) {
	auto startTime = chrono::high_resolution_clock::now();
	while (!newAddedSR3s.empty()) {
		//adjust stages according to the new added SR3s
		SR3Stages(newAddedSR3s, preNode->SR3s, preNode->stages);

		//conduct the CG
		bool integerFlag = false;
		double preLowerBound = ColumnGeneration(preNode, integerFlag, false, outPut);
		if (preLowerBound > g_dualRootNode)
			g_dualRootNode = preLowerBound;

		//control the solution time
		auto endTime = chrono::high_resolution_clock::now();
		if (g_BPTime + chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count() / 1000.0 >= MAXMUMSOLTIME) {
			g_timeLimitReach = true;
			break;
		}

		//judge premature termination rules
		if (int(ceil(preLowerBound)) == g_binpackingUB) {
			g_binpackingUB = int(ceil(preLowerBound));
			delete preNode;
			cout << "No branches is needed for this node!" << endl;
			outPut << "No branches is needed for this node!" << endl;
			return 1;
		}
		//Judge the integer solution of the present node
		if (integerFlag) {
			g_binpackingUB = int(ceil(preLowerBound));
			delete preNode;
			cout << "No branches is needed for this node!" << endl;
			outPut << "No branches is needed for this node!" << endl;
			return 1;
		}

		//Separate more SR3s
		newAddedSR3s.clear();
		SeparateSR3(preNode->preSolution, preNode->allCols, preNode->SR3s, newAddedSR3s);
	}
	return 0;
}


//call the branch and price to solve the submodular bin packing problem
void Branch_and_pricing(Args& args) {
	auto bpStartTime = chrono::high_resolution_clock::now();
	/*read g_instance*/
	ReadInstances(args);
	ofstream outPut(args.output_file, ios::app);
	CopyInstance(g_orgInstance, g_instance);	//keep the instance information to the original instance
	g_orgInstance.n_items = g_instance.n_items;
	g_orgInstance.rho = g_instance.rho;
	g_orgInstance.capacity = g_instance.capacity;

	/*run the knapsack problem*/
	g_maxItemNum = LabelSettingSolveKnapsack(args);	//get the largest number of items can contained in one bin

	/*call the heuristic to solve the submodular bin packing*/
	CopyInstance(g_instance, g_orgInstance);		//keep the instance information to the original instance
	vector<Bin*> heuSol;
	int heuBinNum = HeuristicForBinpacking(heuSol);
	CopySolution(g_bestSol_binpacking, heuSol);
	g_binpackingUB = heuBinNum;						//the golbal upper bound

	stack<BranchNode*> Nodes;						//record all the nodes in the search tree
	/*create initial columns*/
	vector<Bin*> rootCols;
	vector<Stage> rootStages;
	GenerateInitCols(rootCols);
	//add heuristic solution to the preCols
	rootCols.insert(rootCols.end(), heuSol.begin(), heuSol.end());
	BranchNode* rootNode = new BranchNode();
	rootNode->allCols = rootCols;
	bool integerFlag = true;

	///*call the heuristic CG without truncating to generate more initial columns and call MIP to improve upper bound*/
	////set parameters
	//int org_g_upper_lower_dual = g_upper_lower_dual;
	//double org_g_MIPMaxTime = g_MIPMaxTime;
	//double org_controlNum = g_controlNum;
	//g_controlNum = 1000000;
	////g_upper_lower_dual = 2;
	//g_MIPMaxTime = 1e10;
	////call heuristic CG
	//double lowerBound = ColumnGeneration(rootNode, integerFlag, true, outPut, true);
	////call MIP
	//CallMIPtoSolve(rootNode);
	////reset parameters
	////g_upper_lower_dual = org_g_upper_lower_dual;
	//g_MIPMaxTime = org_g_MIPMaxTime;
	//g_controlNum = org_controlNum;

	//cout << "Start solve the root node! " << endl;
	auto rootStartTime = chrono::high_resolution_clock::now();
	/*call CG for the root node*/
	integerFlag = true;
	double lowerBound = ColumnGeneration_rootNode(rootNode, integerFlag, true, outPut);
	rootNode->lowerBound = lowerBound;
	g_worstDual = g_dualRootNode = lowerBound;
	auto rootEndTime = chrono::high_resolution_clock::now();
	cout << "The root node CG iteration number is: " << g_CGIterations << endl;
	cout << "The number of DOIs added to the root nodeis: " << g_validDOIs << endl;
	outPut << "The root node CG iteration number is: " << g_CGIterations << endl;
	outPut << "The number of DOIs added to the root nodeis: " << g_validDOIs << endl;
	if (g_reRunMPwithoutDOIs) {
		cout << "The DOIs are selected in the basis!" << endl;
		outPut << "The DOIs are selected in the basis!" << endl;
	}
	else {
		cout << "The DOIs are NOT selected in the basis!" << endl;
		outPut << "The DOIs are NOT selected in the basis!" << endl;
	}
	//Judge the current node should be ended or not
	if (g_errorControl || g_timeLimitReach || JgeRootNodeEnd(lowerBound, rootCols, outPut, integerFlag)) {
		if (g_timeLimitReach) {
			cout << "The root node CG solution reach time limit." << endl;
			outPut << "The root node CG solution reach time limit." << endl;
		}
		if (g_errorControl) {
			cout << "The root node CG solution encounter error during the labeling." << endl;
			outPut << "The root node CG solution encounter error during the labeling." << endl;
		}
		auto bpEndTime = chrono::high_resolution_clock::now();
		cout << "The dual bound of the root node is " << g_dualRootNode << endl;
		cout << "The worst dual bound during branch " << g_worstDual << endl;
		cout << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		cout << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		cout << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		cout << "The total CG iteration number is: " << g_CGIterations << endl;
		cout << "The time spent on heuristic is " << g_heuristicTime << endl;
		cout << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		cout << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		cout << "The time spent on pricing is " << g_pricingTime << endl;
		cout << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of pattern number branches are " << g_patternBranchNum << endl;
		cout << "The number of arc branches are " << g_arcBranchNum << endl;
		cout << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		cout << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		cout << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of columns generated by the HLA is " << g_HLACols << endl;
		cout << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut << "The dual bound of the root node is " << g_dualRootNode << endl;
		outPut << "The worst dual bound during branch " << g_worstDual << endl;
		outPut << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		outPut << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		outPut << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		outPut << "The total CG iteration number is: " << g_CGIterations << endl;
		outPut << "The time spent on heuristic is " << g_heuristicTime << endl;
		outPut << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		outPut << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		outPut << "The time spent on pricing is " << g_pricingTime << endl;
		outPut << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of pattern number branches are " << g_patternBranchNum << endl;
		outPut << "The number of arc branches are " << g_arcBranchNum << endl;
		outPut << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		outPut << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		outPut << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of columns generated by the HLA is " << g_HLACols << endl;
		outPut << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut.close();
		return;
	}

	/*call the MIP for the root node to get a better upper bound*/
	cout << "After solving the root node, call MIP to improve the upper bound." << endl;
	outPut << "After solving the root node, call MIP to improve the upper bound." << endl;
	CallMIPtoSolve(rootNode);
	//Judge the root node should be ended or not
	if (JgeRootNodeEnd(lowerBound, rootCols, outPut, integerFlag)) {
		auto bpEndTime = chrono::high_resolution_clock::now();
		cout << "The dual bound of the root node is " << g_dualRootNode << endl;
		cout << "The worst dual bound during branch " << g_worstDual << endl;
		cout << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		cout << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		cout << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		cout << "The total CG iteration number is: " << g_CGIterations << endl;
		cout << "The time spent on heuristic is " << g_heuristicTime << endl;
		cout << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		cout << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		cout << "The time spent on pricing is " << g_pricingTime << endl;
		cout << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of pattern branches are " << g_patternBranchNum << endl;
		cout << "The number of arc branches are " << g_arcBranchNum << endl;
		cout << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		cout << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		cout << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of columns generated by the HLA is " << g_HLACols << endl;
		cout << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut << "The dual bound of the root node is " << g_dualRootNode << endl;
		outPut << "The worst dual bound during branch " << g_worstDual << endl;
		outPut << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		outPut << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		outPut << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		outPut << "The total CG iteration number is: " << g_CGIterations << endl;
		outPut << "The time spent on heuristic is " << g_heuristicTime << endl;
		outPut << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		outPut << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		outPut << "The time spent on pricing is " << g_pricingTime << endl;
		outPut << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of pattern branches are " << g_patternBranchNum << endl;
		outPut << "The number of arc branches are " << g_arcBranchNum << endl;
		outPut << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		outPut << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		outPut << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of columns generated by the HLA is " << g_HLACols << endl;
		outPut << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut.close();
		return;
	}
	auto bpEndTime = chrono::high_resolution_clock::now();
	g_BPTime = chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0;

	/*call the heuristic CG without truncating to generate more initial columns and call MIP to improve upper bound*/
	cout << "After call MIP for root node, call high precision CG." << endl;
	outPut << "After call MIP for root node, call high precision CG." << endl;
	//set parameters
	int org_g_upper_lower_dual = g_upper_lower_dual;
	double org_g_MIPMaxTime = g_MIPMaxTime;
	double org_controlNum = g_controlNum;
	g_controlNum = 1000000;
	//g_upper_lower_dual = 2;
	g_MIPMaxTime = 300;
	g_dualBoundRoundNum = 1;
	g_maximumTimeDualBound = 300;
	//call heuristic CG
	lowerBound = ColumnGeneration(rootNode, integerFlag, true, outPut, true);
	//call MIP
	CallMIPtoSolve(rootNode);
	//reset parameters
	//g_upper_lower_dual = org_g_upper_lower_dual;
	g_MIPMaxTime = org_g_MIPMaxTime;
	g_controlNum = org_controlNum;
	g_dualBoundRoundNum = 1;
	g_maximumTimeDualBound = 300;
	//Judge the root node should be ended or not
	if (g_timeLimitReach || JgeRootNodeEnd(lowerBound, rootCols, outPut, integerFlag)) {
		auto bpEndTime = chrono::high_resolution_clock::now();
		if (g_timeLimitReach) {
			cout << "Call the heuristic CG without truncating reach time limit." << endl;
			outPut << "Call the heuristic CG without truncating reach time limit." << endl;
		}
		cout << "The dual bound of the root node is " << g_dualRootNode << endl;
		cout << "The worst dual bound during branch " << g_worstDual << endl;
		cout << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		cout << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		cout << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		cout << "The total CG iteration number is: " << g_CGIterations << endl;
		cout << "The time spent on heuristic is " << g_heuristicTime << endl;
		cout << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		cout << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		cout << "The time spent on pricing is " << g_pricingTime << endl;
		cout << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of pattern branches are " << g_patternBranchNum << endl;
		cout << "The number of arc branches are " << g_arcBranchNum << endl;
		cout << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		cout << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		cout << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of columns generated by the HLA is " << g_HLACols << endl;
		cout << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut << "The dual bound of the root node is " << g_dualRootNode << endl;
		outPut << "The worst dual bound during branch " << g_worstDual << endl;
		outPut << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		outPut << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		outPut << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		outPut << "The total CG iteration number is: " << g_CGIterations << endl;
		outPut << "The time spent on heuristic is " << g_heuristicTime << endl;
		outPut << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		outPut << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		outPut << "The time spent on pricing is " << g_pricingTime << endl;
		outPut << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of pattern branches are " << g_patternBranchNum << endl;
		outPut << "The number of arc branches are " << g_arcBranchNum << endl;
		outPut << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		outPut << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		outPut << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of columns generated by the HLA is " << g_HLACols << endl;
		outPut << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut.close();
		return;
	}
	bpEndTime = chrono::high_resolution_clock::now();
	g_BPTime = chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0;


	/*call the compact model to test the feasibility of the upper bound with floor(LB) + 1*/
	int compactFlag = 2;
	if (g_useCompactModel)
		compactFlag = SolveCompactSMBPModel(args, lowerBound, int(floor(lowerBound)) + 1);
	//Jge if branch is needed
	if (compactFlag == 0 || compactFlag == 1) {
		auto bpEndTime = chrono::high_resolution_clock::now();
		cout << "Call the compact model successes close the model!" << endl;
		cout << "The dual bound of the root node is " << g_dualRootNode << endl;
		cout << "The worst dual bound during branch " << g_worstDual << endl;
		cout << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		cout << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		cout << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		cout << "The total CG iteration number is: " << g_CGIterations << endl;
		cout << "The time spent on heuristic is " << g_heuristicTime << endl;
		cout << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		cout << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		cout << "The time spent on pricing is " << g_pricingTime << endl;
		cout << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of pattern branches are " << g_patternBranchNum << endl;
		cout << "The number of arc branches are " << g_arcBranchNum << endl;
		cout << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		cout << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		cout << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of columns generated by the HLA is " << g_HLACols << endl;
		cout << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut << "Call the compact model successes close the model!" << endl;
		outPut << "The dual bound of the root node is " << g_dualRootNode << endl;
		outPut << "The worst dual bound during branch " << g_worstDual << endl;
		outPut << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		outPut << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		outPut << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		outPut << "The total CG iteration number is: " << g_CGIterations << endl;
		outPut << "The time spent on heuristic is " << g_heuristicTime << endl;
		outPut << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		outPut << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		outPut << "The time spent on pricing is " << g_pricingTime << endl;
		outPut << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of pattern branches are " << g_patternBranchNum << endl;
		outPut << "The number of arc branches are " << g_arcBranchNum << endl;
		outPut << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		outPut << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		outPut << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of columns generated by the HLA is " << g_HLACols << endl;
		outPut << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut.close();
		return;
	}

	/*Separate the Subset row inequalities*/
	//prepare the SR3 candidates set
	vector<unordered_set<int>> newAddedSR3s;
	GetAllPermutation(g_instance);//get all the candidates of SR3s, also used in separate DOIs
	SeparateSR3(rootNode->preSolution, rootNode->allCols, rootNode->SR3s, newAddedSR3s);

	/*If the SR3 are separeted successfully, then do the columns and cuts generation procedure*/
	cout << "After call high precision CG, call CRG." << endl;
	outPut << "After call high precision CG, call CRG." << endl;
	bool closeFlag = false;
	if (!newAddedSR3s.empty())
		closeFlag = ColumnAndCutsGeneration(newAddedSR3s, rootNode, outPut);
	if (g_timeLimitReach || closeFlag) {
		auto bpEndTime = chrono::high_resolution_clock::now();
		if (g_timeLimitReach) {
			cout << "Columns and cuts generation reach time limit." << endl;
			outPut << "Columns and cuts generation reach time limit." << endl;
		}
		cout << "Call the cloumns and cuts generation close the model!" << endl;
		cout << "The dual bound of the root node is " << g_dualRootNode << endl;
		cout << "The worst dual bound during branch " << g_worstDual << endl;
		cout << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		cout << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		cout << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		cout << "The total CG iteration number is: " << g_CGIterations << endl;
		cout << "The time spent on heuristic is " << g_heuristicTime << endl;
		cout << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		cout << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		cout << "The time spent on pricing is " << g_pricingTime << endl;
		cout << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of pattern branches are " << g_patternBranchNum << endl;
		cout << "The number of arc branches are " << g_arcBranchNum << endl;
		cout << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		cout << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		cout << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		cout << "The number of columns generated by the HLA is " << g_HLACols << endl;
		cout << "The number of columns generated by the ELA is " << g_ELACols << endl;
		cout << "The number of SR3s added are " << g_SR3Num << endl;
		outPut << "Call the compact model successes close the model!" << endl;
		outPut << "The dual bound of the root node is " << g_dualRootNode << endl;
		outPut << "The worst dual bound during branch " << g_worstDual << endl;
		outPut << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
		outPut << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
		outPut << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
		outPut << "The total CG iteration number is: " << g_CGIterations << endl;
		outPut << "The time spent on heuristic is " << g_heuristicTime << endl;
		outPut << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
		outPut << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
		outPut << "The time spent on pricing is " << g_pricingTime << endl;
		outPut << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of pattern branches are " << g_patternBranchNum << endl;
		outPut << "The number of arc branches are " << g_arcBranchNum << endl;
		outPut << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
		outPut << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
		outPut << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
		outPut << "The number of columns generated by the HLA is " << g_HLACols << endl;
		outPut << "The number of columns generated by the ELA is " << g_ELACols << endl;
		outPut << "The number of SR3s added are " << g_SR3Num << endl;
		outPut.close();
		return;
	}

	cout << "The dual bound of the root node is " << g_dualRootNode << endl;
	cout << "The worst dual bound during branch " << g_worstDual << endl;
	cout << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
	cout << "The best upper bound after solving the root node is " << g_binpackingUB << " bins!" << endl;
	cout << "Begin branching!" << endl;
	outPut << "The dual bound of the root node is " << g_dualRootNode << endl;
	outPut << "The worst dual bound during branch " << g_worstDual << endl;
	outPut << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
	outPut << "The best upper bound after solving the root node is " << g_binpackingUB << " bins!" << endl;
	outPut << "Begin branching!" << endl;
	bpEndTime = chrono::high_resolution_clock::now();
	g_BPTime = chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0;

	/*start to branch*/
	//choose a branch pattern
	BranchInfo preBranchInfo = BranchInfo();
	//bool patternBranch = ChooseBranchBinNum(rootNode->lowerBound, rootNode->branchBins, chosenBranchPattern);
	bool patternBranch = ChooseBranchPattern(rootNode->preSolution, rootNode->allCols, rootNode->branchPatterns, preBranchInfo.prePattern);

	if (!patternBranch) {
		//choose a branch item pair
		ChooseBranchItemPair(rootNode->preSolution, rootNode->allCols, rootNode->branchArcs, rootNode->SR3s, preBranchInfo.itemPair);
		++g_arcBranchNum;
	}
	else
		++g_patternBranchNum;
	//create two child nodes
	CreateTwoChildNodes(rootNode, patternBranch, preBranchInfo, Nodes, outPut);
	delete rootNode;

	try {
		//Search the branch tree
		while (!Nodes.empty()) {
			//control solution time
			bpEndTime = chrono::high_resolution_clock::now();
			if (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 > MAXMUMSOLTIME) {
				cout << "Reach the maximum solution time!" << endl;
				outPut << "Reach the maximum solution time!" << endl;
				while (!Nodes.empty()) {
					delete Nodes.top();
					Nodes.pop();
				}
				break;
			}

			//get a child node
			BranchNode* preNode = Nodes.top();
			Nodes.pop();
			g_controlNum = 1000; //reset decimal precision control
			g_dualBoundRoundNum = 1;
			g_maximumTimeDualBound = 300;

			//choose a branch pattern
			//get the new branch item pair
			preBranchInfo = BranchInfo();
			patternBranch = ChooseBranchPattern(preNode->preSolution, preNode->allCols, preNode->branchPatterns, preBranchInfo.prePattern);
			if (!patternBranch) {
				ChooseBranchItemPair(preNode->preSolution, preNode->allCols, preNode->branchArcs, preNode->SR3s, preBranchInfo.itemPair);
				////test duplication
				//if (find(preNode->branchArcs.begin(), preNode->branchArcs.end(), preBranchInfo) != preNode->branchArcs.end()) {
				//	int a = 0;
				//	cout << "branch arc duplicated!" << endl;
				//}
				++g_arcBranchNum;
			}
			else
				++g_patternBranchNum;

			//create two child nodes
			CreateTwoChildNodes(preNode, patternBranch, preBranchInfo, Nodes, outPut);

			/*call the MIP for the root node to get a better upper bound*/
			if (abs(round(preNode->lowerBound) - preNode->lowerBound) <= 1e-2)
				CallMIPtoSolve(preNode);

			//delete present solved node
			delete preNode;
			bpEndTime = chrono::high_resolution_clock::now();
			g_BPTime = chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0;
		}
	}
	catch (exception& e) {
		cout << "****Error exception: ****" << e.what() << endl;
		outPut << "****Error exception: ****" << e.what() << endl;
	}

	bpEndTime = chrono::high_resolution_clock::now();
	cout << "The dual bound of the root node is " << g_dualRootNode << endl;
	cout << "The worst dual bound during branch " << g_worstDual << endl;
	cout << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
	cout << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
	cout << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
	cout << "The total CG iteration number is: " << g_CGIterations << endl;
	cout << "The time spent on heuristic is " << g_heuristicTime << endl;
	cout << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
	cout << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
	cout << "The time spent on pricing is " << g_pricingTime << endl;
	cout << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
	cout << "The number of pattern branches are " << g_patternBranchNum << endl;
	cout << "The number of arc branches are " << g_arcBranchNum << endl;
	cout << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
	cout << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
	cout << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
	cout << "The number of columns generated by the HLA is " << g_HLACols << endl;
	cout << "The number of columns generated by the ELA is " << g_ELACols << endl;
	cout << "The number of SR3s added are " << g_SR3Num << endl;
	outPut << "The dual bound of the root node is " << g_dualRootNode << endl;
	outPut << "The worst dual bound during branch " << g_worstDual << endl;
	outPut << "The upper bound obtain by the HGS is " << heuBinNum << " bins!" << endl;
	outPut << "The best upper bound is " << g_binpackingUB << " bins!" << endl;
	outPut << "The total time for BP is " << chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0 << endl;
	outPut << "The total CG iteration number is: " << g_CGIterations << endl;
	outPut << "The time spent on heuristic is " << g_heuristicTime << endl;
	outPut << "The time for solving root node is " << chrono::duration_cast<chrono::milliseconds>(rootEndTime - rootStartTime).count() / 1000.0 << endl;
	outPut << "The time spent on adjusting stages is " << g_adjustStagesTime << endl;
	outPut << "The time spent on pricing is " << g_pricingTime << endl;
	outPut << "The average time for each node is " << (chrono::duration_cast<chrono::milliseconds>(bpEndTime - bpStartTime).count() / 1000.0) / (1 + g_arcBranchNum * 2) << endl;
	outPut << "The number of pattern branches are " << g_patternBranchNum << endl;
	outPut << "The number of arc branches are " << g_arcBranchNum << endl;
	outPut << "The number of nodes are " << 1 + g_arcBranchNum * 2 << endl;
	outPut << "The maximum depth of the B_B tree is " << g_maxNodeDepth << endl;
	outPut << "The average depth of the B_B tree is " << g_nodeDepthSum / (1 + g_arcBranchNum * 2) << endl;
	outPut << "The number of columns generated by the HLA is " << g_HLACols << endl;
	outPut << "The number of columns generated by the ELA is " << g_ELACols << endl;
	outPut << "The number of SR3s added are " << g_SR3Num << endl;
	outPut.close();
}